import fs from 'fs';
import { z } from 'zod';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { buildPrompt } from './prompt-builder';

// Schema for extracted page data
export const PageExtractionSchema = z.object({
  page: z.number(),
  text: z.string(),
  format: z.enum(["markdown", "json", "xml"]),
  images: z.array(z.string()).optional(),
});

export type PageExtraction = z.infer<typeof PageExtractionSchema>;

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

/**
 * Extract structured data from a WebP image using Gemini multimodal AI
 */
export async function extractPage(sessionId: string, page: number): Promise<PageExtraction> {
  try {
    // Try both naming conventions (page-1.webp and page-01.webp)
    const imagePath1 = `./uploads/${sessionId}/pages/page-${page}.webp`;
    const imagePath2 = `./uploads/${sessionId}/pages/page-${String(page).padStart(2, '0')}.webp`;
    
    const imagePath = fs.existsSync(imagePath1) ? imagePath1 : imagePath2;
    
    // Check if the image file exists
    if (!fs.existsSync(imagePath)) {
      throw new Error(`Image file not found: ${imagePath}`);
    }

    // Read and encode the image
    const imageBuffer = fs.readFileSync(imagePath);
    const base64Image = imageBuffer.toString('base64');

    // Get the Gemini model
    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-pro' });

    // Build the dynamic prompt using templates
    const prompt = await buildPrompt({
      sessionId,
      pageNumber: page,
      outputFormat: 'json',
      schemaType: 'structured_extraction',
    });

    // Create the multimodal request
    const result = await model.generateContent([
      {
        inlineData: {
          mimeType: 'image/webp',
          data: base64Image,
        },
      },
      { text: prompt },
    ]);

    const response = await result.response;
    const responseText = response.text();

    // Try to extract JSON from the response
    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No valid JSON found in Gemini response');
    }

    const jsonString = jsonMatch[0];
    const parsedData = JSON.parse(jsonString);

    // Validate the response with Zod
    const validatedData = PageExtractionSchema.parse(parsedData);

    // Ensure output directory exists
    const outputDir = `./outputs/${sessionId}`;
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Save the extracted data to a file
    const outputPath = `${outputDir}/page-${page}.json`;
    fs.writeFileSync(outputPath, JSON.stringify(validatedData, null, 2));

    console.log(`âœ“ Extracted page ${page} for session ${sessionId}`);
    return validatedData;

  } catch (error) {
    console.error(`Error extracting page ${page} for session ${sessionId}:`, error);
    
    // Return a fallback extraction
    const fallbackData: PageExtraction = {
      page,
      text: `Error extracting content: ${error instanceof Error ? error.message : 'Unknown error'}`,
      format: 'markdown',
    };

    // Still try to save the fallback data
    try {
      const outputDir = `./outputs/${sessionId}`;
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      const outputPath = `${outputDir}/page-${page}.json`;
      fs.writeFileSync(outputPath, JSON.stringify(fallbackData, null, 2));
    } catch (saveError) {
      console.error('Failed to save fallback data:', saveError);
    }

    return fallbackData;
  }
}

/**
 * Get all WebP image files for a session
 */
export function getPageFiles(sessionId: string): number[] {
  const pagesDir = `./uploads/${sessionId}/pages`;
  
  if (!fs.existsSync(pagesDir)) {
    return [];
  }

  try {
    const files = fs.readdirSync(pagesDir);
    const pageFiles = files
      .filter(file => file.startsWith('page-') && file.endsWith('.webp'))
      .map(file => {
        const match = file.match(/page-(\d+)\.webp/);
        return match ? parseInt(match[1]) : 0;
      })
      .filter(pageNum => pageNum > 0)
      .sort((a, b) => a - b);

    return pageFiles;
  } catch (error) {
    console.error('Error reading page files:', error);
    return [];
  }
}

/**
 * Check if extraction is complete for a session
 */
export function isExtractionComplete(sessionId: string, totalPages: number): boolean {
  const outputDir = `./outputs/${sessionId}`;
  
  if (!fs.existsSync(outputDir)) {
    return false;
  }

  try {
    const files = fs.readdirSync(outputDir);
    const extractedPages = files
      .filter(file => file.startsWith('page-') && file.endsWith('.json'))
      .map(file => {
        const match = file.match(/page-(\d+)\.json/);
        return match ? parseInt(match[1]) : 0;
      })
      .filter(pageNum => pageNum > 0);

    return extractedPages.length >= totalPages;
  } catch (error) {
    console.error('Error checking extraction completion:', error);
    return false;
  }
}